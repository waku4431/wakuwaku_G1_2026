<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>わくわくG1サイト 2026</title>

  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>

  <style>
    :root{
      --bg:#0b1020;
      --text:#e9eefc;
      --muted:#9fb0dd;
      --border:rgba(255,255,255,.10);
      --accent:#7aa2ff;
      --danger:#ff6b6b;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", "Hiragino Kaku Gothic ProN", "Yu Gothic", sans-serif;
      background: radial-gradient(1200px 600px at 50% -100px, #1b2a5a 0%, var(--bg) 55%, #070a14 100%);
      color:var(--text);
    }
    header{
      padding:16px 14px 10px;
      max-width:1200px; margin:0 auto;
      display:flex; flex-direction:column; gap:10px;
    }
    h1{margin:0; font-size:20px; letter-spacing:.2px}

    .tabs{display:flex; gap:8px; flex-wrap:wrap;}
    .tabbtn{
      border:1px solid var(--border);
      background: rgba(255,255,255,.03);
      color: var(--text);
      padding:8px 12px;
      border-radius:12px;
      cursor:pointer;
      font-size:13px;
      white-space:nowrap;
    }
    .tabbtn.active{
      border-color: rgba(122,162,255,.6);
      background: rgba(122,162,255,.12);
    }

    .wrap{max-width:1200px; margin:0 auto; padding:10px 12px 26px;}

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border:1px solid var(--border);
      border-radius:16px;
      padding:8px;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
      overflow:hidden;
    }

    .form{
      display:grid;
      gap:10px;
      grid-template-columns: 1fr 1fr;
    }
    .form .full{grid-column:1 / -1;}
    label{display:block; font-size:12px; color:var(--muted); margin-bottom:6px;}
    input, select{
      width:100%;
      padding:12px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.20);
      color:var(--text);
      outline:none;
      font-size:16px;
    }
    input::placeholder{color:rgba(233,238,252,.45);}
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .btn{
      border:1px solid var(--border);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      font-size:13px;
    }
    .btn.primary{
      border-color: rgba(122,162,255,.6);
      background: rgba(122,162,255,.18);
    }
    .badge{
      border:1px solid var(--border);
      padding:6px 10px;
      border-radius:999px;
      background:rgba(255,255,255,.03);
      color: var(--muted);
      font-size:12px;
    }
    .hidden{display:none !important;}
    .hint{font-size:12px; color:rgba(233,238,252,.65);}

    .grid{
      display:grid; gap:12px;
      grid-template-columns: repeat(12, 1fr);
    }
    .c1{grid-column: span 4;}
    .c2{grid-column: span 4;}
    .c3{grid-column: span 4;}
    .c4{grid-column: span 4;}
    .c5{grid-column: span 4;}
    .c6{grid-column: span 4;}

    .chart{width:100%; height:320px;}
    .chartTall{width:100%; height:360px;}

    /* 収支表タブ */
    .tableWrap{
      overflow-x:hidden; /* ★スマホでも横スクロールさせない（崩れない設計にする） */
      -webkit-overflow-scrolling:touch;
      border-radius:12px;
      width:100%;
    }
    .chartTable{
      width:100%;
      height:560px;
    }

    @media (max-width: 900px){
      .form{grid-template-columns: 1fr;}
      .c1,.c2,.c3,.c4,.c5,.c6{grid-column: span 12;}
      .chart{height:295px;}
      .chartTall{height:335px;}
      .chartTable{height:520px;}
    }

    a.linkcard{
      display:block;
      flex:1;
      min-width: 240px;
      text-decoration:none;
      color: var(--text);
      border:1px solid var(--border);
      background: rgba(255,255,255,.03);
      border-radius:16px;
      padding:14px;
    }
    a.linkcard:hover{
      background: rgba(255,255,255,.06);
      border-color: rgba(255,255,255,.18);
    }
    .linktitle{font-weight:800; margin-bottom:6px;}
    .linkurl{
      font-size:12px;
      color: rgba(233,238,252,.65);
      word-break: break-all;
    }
  </style>
</head>

<body>
<header>
  <div><h1>わくわくG1サイト 2026</h1></div>
  <div class="tabs">
    <button class="tabbtn active" data-tab="input">入力</button>
    <button class="tabbtn" data-tab="dashboard">ダッシュボード</button>
    <button class="tabbtn" data-tab="table">収支表</button>
    <button class="tabbtn" data-tab="history">History</button>
  </div>
</header>

<div class="wrap">
  <!-- INPUT -->
  <section id="tab-input" class="card">
    <div class="row" style="justify-content:space-between; margin-bottom:8px;">
      <div class="hint">
        送信後も <b>参加者/レース</b> を保持。金額も保持したい場合は右の設定をON。
      </div>
      <label class="row" style="margin:0; gap:8px;">
        <input id="keepAmount" type="checkbox" style="width:auto; transform:scale(1.1);" />
        <span class="hint">金額も保持</span>
      </label>
    </div>

    <form id="entryForm" class="form">
      <div>
        <label>参加者</label>
        <select id="name" required></select>
      </div>

      <div>
        <label>G1レース名</label>
        <select id="race" required></select>
      </div>

      <div>
        <label>掛け金（円）</label>
        <input id="bet" type="number" inputmode="numeric" min="0" step="100" placeholder="例: 1000" required />
      </div>

      <div>
        <label>回収額（円）</label>
        <input id="pay" type="number" inputmode="numeric" min="0" step="100" placeholder="例: 0" required />
      </div>

      <div class="full row" style="justify-content:space-between;">
        <button class="btn primary" type="submit">送信</button>
        <div class="row">
          <button class="btn" type="button" id="toDash">ダッシュボードへ</button>
        </div>
      </div>
    </form>
  </section>

  <!-- DASHBOARD -->
  <section id="tab-dashboard" class="hidden">
    <div class="row" style="justify-content:space-between; margin: 0 0 10px 0;">
      <span class="badge" id="updatedDash">updated: -</span>
      <div class="row">
        <button class="btn" id="reloadDashBtn" type="button">再読み込み</button>
        <button class="btn" id="toInputFromDash" type="button">入力へ</button>
      </div>
    </div>

    <div class="grid">
      <div class="card c1"><h2 style="margin:0 0 6px; color:var(--muted); font-size:13px;">掛け金合計 [円]</h2><div id="barBet" class="chart"></div></div>
      <div class="card c2"><h2 style="margin:0 0 6px; color:var(--muted); font-size:13px;">収支 [円]</h2><div id="barProfit" class="chart"></div></div>
      <div class="card c3"><h2 style="margin:0 0 6px; color:var(--muted); font-size:13px;">回収率 [%]</h2><div id="barRoi" class="chart"></div></div>

      <div class="card c4"><h2 style="margin:0 0 6px; color:var(--muted); font-size:13px;">累積掛け金 [円]</h2><div id="lineCumBet" class="chartTall"></div></div>
      <div class="card c5"><h2 style="margin:0 0 6px; color:var(--muted); font-size:13px;">累積収支 [円] <span class="hint">0ライン</span></h2><div id="lineCumProfit" class="chartTall"></div></div>
      <div class="card c6"><h2 style="margin:0 0 6px; color:var(--muted); font-size:13px;">累積回収率 [%]</h2><div id="lineCumRoi" class="chartTall"></div></div>
    </div>
  </section>

  <!-- TABLE -->
  <section id="tab-table" class="hidden">
    <div class="row" style="justify-content:space-between; margin: 0 0 10px 0;">
      <span class="badge" id="updatedTable">updated: -</span>
      <div class="row">
        <button class="btn" id="reloadTableBtn" type="button">再読み込み</button>
        <button class="btn" id="toInputFromTable" type="button">入力へ</button>
      </div>
    </div>

    <div class="card">
      <h2 style="margin:0 0 6px; color:var(--muted); font-size:13px;">収支表（ヒートマップ）</h2>
      <div id="profitTableWrap" class="tableWrap">
        <div id="profitTable" class="chartTable"></div>
      </div>
    </div>
  </section>

  <!-- HISTORY -->
  <section id="tab-history" class="hidden">
    <div class="card">
      <h2 style="margin:0 0 10px; color:var(--muted); font-size:13px;">過去の結果</h2>

      <div class="row" style="gap:12px;">
        <a class="linkcard" href="https://waku4431.github.io/wakuwaku_G1/" target="_blank" rel="noopener">
          <div class="linktitle">2025（去年のサイト）</div>
          <div class="linkurl">https://waku4431.github.io/wakuwaku_G1/</div>
        </a>

        <a class="linkcard" href="https://docs.google.com/spreadsheets/d/1V1nxbAoVL6SjKAgII8QPmEYw8A5YI-tZUzYFDhKDx1Y/edit?gid=614154890#gid=614154890" target="_blank" rel="noopener">
          <div class="linktitle">2024（スプレッドシート）</div>
          <div class="linkurl">https://docs.google.com/spreadsheets/d/1V1nxbAoVL6SjKAgII8QPmEYw8A5YI-tZUzYFDhKDx1Y/</div>
        </a>
      </div>

      <div class="hint" style="margin-top:10px;">※リンクは新しいタブで開きます</div>
    </div>
  </section>
</div>

<script>
  // ========= 本番WebアプリURL =========
  const GAS_BASE = "https://script.google.com/macros/s/AKfycbw1jiY51U3elE5tyArrcmDH0nYKtJ3N4zrnHx6TNmzojIVOl4-njJaIC7WUlcgp32sbXA/exec";

  // ========= マスタ =========
  const PARTICIPANTS = ["わくだ","きよもと","せきざわ","たきざわ","粗品"];

  // 入力用（あなたの元の表示そのまま）
  const RACES = [
    "フェブラリーステークス（2月22日）",
    "高松宮記念（3月29日）",
    "大阪杯（4月5日）",
    "桜花賞（4月12日）",
    "皐月賞（4月19日）",
    "天皇賞（春）（5月3日）",
    "NHKマイルカップ（5月10日）",
    "ヴィクトリアマイル（5月17日）",
    "オークス（5月24日）",
    "日本ダービー（5月31日）",
    "安田記念（6月7日）",
    "宝塚記念（6月14日）",
    "スプリンターズステークス（9月27日）",
    "秋華賞（10月18日）",
    "菊花賞（10月25日）",
    "天皇賞（秋）（11月1日）",
    "エリザベス女王杯（11月15日）",
    "マイルチャンピオンシップ（11月22日）",
    "ジャパンカップ（11月29日）",
    "チャンピオンズカップ（12月6日）",
    "阪神ジュベナイルフィリーズ（12月13日）",
    "朝日杯フューチュリティステークス（12月20日）",
    "ホープフルステークス（12月26日）",
    "有馬記念（12月27日）"
  ];

  // 収支表（表示用）: 日付なし・省略名（あなたの指定）
  const TABLE_RACES = [
    "フェブラリーS",
    "高松宮記念",
    "大阪杯",
    "桜花賞",
    "皐月賞",
    "天皇賞（春）",
    "NHKマイルカップ",
    "ヴィクトリアマイル",
    "優駿牝馬（オークス）",
    "東京優駿（日本ダービー）",
    "安田記念",
    "宝塚記念",
    "スプリンターズS",
    "秋華賞",
    "菊花賞",
    "天皇賞（秋）",
    "エリザベス女王杯",
    "マイルチャンピオンシップ",
    "ジャパンカップ",
    "チャンピオンズカップ",
    "阪神ジュベナイルフィリーズ",
    "朝日杯フューチュリティS",
    "ホープフルS",
    "有馬記念"
  ];

  // ========= モバイル判定 =========
  const isMobile = () => window.innerWidth <= 420;

  // ========= 色固定 =========
  const COLOR_MAP = {
    "わくだ":   "#7aa2ff",
    "きよもと": "#ffd166",
    "せきざわ": "#ff6b6b",
    "たきざわ": "#6ee7b7",
    "粗品":     "#a78bfa",
  };
  const getColor = (name) => COLOR_MAP[name] || "#7aa2ff";

  // ========= 日付 -> レース名 =========
  const RACE_BY_DATE = (() => {
    const map = {};
    for (const s of RACES) {
      const m = s.match(/^(.+?)（(.+?)）$/);
      if (m) map[m[2]] = m[1];
    }
    return map;
  })();
  const getRaceNameByDate = (d) => RACE_BY_DATE[d] || "";

  // ========= 先読みキャッシュ =========
  let cachedAllData = null;
  let cachedAllDataAt = 0;
  let prefetchPromise = null;
  const CACHE_MS = 30 * 1000;

  async function loadData() {
    const url = `${GAS_BASE}?type=all&t=${Date.now()}`;
    const res = await fetch(url, { method:"GET" });
    const json = await res.json();
    if (!json.ok) throw new Error(json.error || "GAS ok=false");
    return json;
  }

  async function getAllDataFast() {
    const now = Date.now();
    if (cachedAllData && (now - cachedAllDataAt) < CACHE_MS) return cachedAllData;

    if (prefetchPromise) {
      const data = await prefetchPromise;
      cachedAllData = data;
      cachedAllDataAt = Date.now();
      prefetchPromise = null;
      return data;
    }

    prefetchPromise = loadData();
    const data = await prefetchPromise;
    cachedAllData = data;
    cachedAllDataAt = Date.now();
    prefetchPromise = null;
    return data;
  }

  function prefetchAllData() {
    if (!prefetchPromise && (!cachedAllData || (Date.now() - cachedAllDataAt) > CACHE_MS)) {
      prefetchPromise = loadData()
        .then(d => {
          cachedAllData = d;
          cachedAllDataAt = Date.now();
          return d;
        })
        .finally(() => { prefetchPromise = null; });
    }
  }

  // ========= 入力保持 =========
  const LS_KEY = "waku_g1_form_state_v1";

  function saveFormState() {
    const keepAmount = document.getElementById("keepAmount").checked;
    const state = {
      keepAmount,
      name: document.getElementById("name").value,
      race: document.getElementById("race").value,
      bet: keepAmount ? document.getElementById("bet").value : "",
      pay: keepAmount ? document.getElementById("pay").value : "",
    };
    localStorage.setItem(LS_KEY, JSON.stringify(state));
  }

  function loadFormState() {
    const raw = localStorage.getItem(LS_KEY);
    if (!raw) return;
    try {
      const s = JSON.parse(raw);
      document.getElementById("keepAmount").checked = !!s.keepAmount;
      if (s.name) document.getElementById("name").value = s.name;
      if (s.race) document.getElementById("race").value = s.race;
      if (s.keepAmount) {
        if (s.bet !== undefined) document.getElementById("bet").value = s.bet;
        if (s.pay !== undefined) document.getElementById("pay").value = s.pay;
      }
    } catch {}
  }

  // ========= タブ切り替え =========
  function setTab(tabName) {
    document.querySelectorAll(".tabbtn").forEach(b => {
      b.classList.toggle("active", b.dataset.tab === tabName);
    });
    document.getElementById("tab-input").classList.toggle("hidden", tabName !== "input");
    document.getElementById("tab-dashboard").classList.toggle("hidden", tabName !== "dashboard");
    document.getElementById("tab-table").classList.toggle("hidden", tabName !== "table");
    document.getElementById("tab-history").classList.toggle("hidden", tabName !== "history");
    localStorage.setItem("waku_g1_active_tab", tabName);

    // 入力以外に行ったら先読み
    if (tabName !== "dashboard" && tabName !== "table") prefetchAllData();
  }

  // ========= POST =========
  async function postEntry({name, race, bet, pay}) {
    const body = new URLSearchParams({ name, race, bet: String(bet), pay: String(pay) });
    const res = await fetch(GAS_BASE, {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8" },
      body
    });
    const text = (await res.text()).trim();
    if (!res.ok || !text.startsWith("OK")) throw new Error("POST失敗: " + text);
    return text;
  }

  // ========= ECharts =========
  const fmtJPY = (v) => new Intl.NumberFormat('ja-JP').format(v ?? 0);
  const fmtPct = (v) => `${Number(v ?? 0).toFixed(2)}%`;

  function safeDispose(chart) {
    try { chart?.dispose?.(); } catch {}
  }

  // ★余白最適化（左と下をさらに詰める）
  function getChartLayout() {
    const mobile = isMobile();
    return {
      mobile,

      gridLeft:  mobile ? 5 : 46,
      gridRight: mobile ? 10 : 14,
      gridTopBar: 18,
      gridTopLine: 30,

      gridBottomBar:  mobile ? 32 : 40,
      gridBottomLine: mobile ? 15 : 34,

      fontAxis: mobile ? 9 : 11,
      fontLegend: mobile ? 10 : 12,
      axisMargin: mobile ? 6 : 8,

      rotateBarX: 35
    };
  }

  function makeBar(el, title, participants, values, isPct=false) {
    const chart = echarts.init(document.getElementById(el));
    const L = getChartLayout();

    chart.setOption({
      backgroundColor:'transparent',
      grid:{ left:L.gridLeft, right:L.gridRight, top:L.gridTopBar, bottom:L.gridBottomBar, containLabel:true },
      xAxis:{
        type:'category',
        data:participants,
        axisLabel:{ color:'rgba(233,238,252,.85)', rotate:L.rotateBarX, fontSize:L.fontAxis, margin:L.axisMargin }
      },
      yAxis:{
        type:'value',
        axisLabel:{
          color:'rgba(233,238,252,.65)',
          formatter:(v)=> isPct?`${v}%`:fmtJPY(v),
          fontSize:L.fontAxis,
          margin:L.axisMargin
        },
        splitLine:{ lineStyle:{ color:'rgba(255,255,255,.08)' } }
      },
      tooltip:{
        trigger:'axis',
        axisPointer:{ type:'shadow' },
        formatter:(ps)=> {
          const p=ps[0], v=Number(p.value??0);
          return `${p.name}<br>${title}: <b>${isPct?fmtPct(v):"¥"+fmtJPY(v)}</b>`;
        }
      },
      series:[{
        type:'bar',
        data:values,
        barMaxWidth:42,
        itemStyle:{
          color:(params)=>getColor(params.name),
          borderRadius:[10,10,0,0]
        },
        label:{
          show:true,
          position:'insideTop',
          color:'rgba(233,238,252,.95)',
          fontSize: L.mobile ? 11 : 12,
          formatter:(p)=> {
            const v=Number(p.value??0);
            return isPct?`${v.toFixed(0)}%`:`¥${fmtJPY(v)}`;
          }
        }
      }]
    });
    return chart;
  }

  // ★折れ線：横軸は「レース回数」
  function makeLines(el, block, isPct=false, showZero=false) {
    const chart = echarts.init(document.getElementById(el));
    const L = getChartLayout();

    const dates = block?.dates ?? [];
    const xLabels = dates.map((_, i) => String(i + 1)); // 1..N

    const legends = block?.series ? Object.keys(block.series) : [];
    const series = legends.map(name => ({
      name,
      type:'line',
      data:block.series[name],
      smooth:false,
      showSymbol:false,
      lineStyle:{ width:2, color:getColor(name) },
      emphasis:{ focus:'series' }
    }));

    const opt = {
      backgroundColor:'transparent',
      legend:{
        data:legends,
        top:0,
        left:0,
        itemWidth:14,
        itemHeight:8,
        textStyle:{ color:'rgba(233,238,252,.75)', fontSize:L.fontLegend }
      },
      grid:{ left:L.gridLeft, right:L.gridRight, top:L.gridTopLine, bottom:L.gridBottomLine, containLabel:true },
      xAxis:{
        type:'category',
        data:xLabels,
        boundaryGap:false,
        axisTick:{ alignWithLabel:true },
        axisLabel:{
          color:'rgba(233,238,252,.75)',
          fontSize:L.fontAxis,
          margin:6,
          interval: 0,
          formatter: (val, idx) => {
            const n = Number(val);
            const last = xLabels.length;
            if (n === 1 || n === last) return String(n);
            return (n % 2 === 0) ? String(n) : "";
          }
        },
        name: "レース回数",
        nameLocation: "middle",
        nameGap: L.mobile ? 20 : 24,
        nameTextStyle:{
          color:'rgba(233,238,252,.65)',
          fontSize: L.mobile ? 10 : 12
        }
      },
      yAxis:{
        type:'value',
        axisLabel:{
          color:'rgba(233,238,252,.65)',
          formatter:(v)=> isPct?`${v}%`:fmtJPY(v),
          fontSize:L.fontAxis,
          margin:L.axisMargin
        },
        splitLine:{ lineStyle:{ color:'rgba(255,255,255,.08)' } }
      },
      tooltip:{
        trigger:'axis',
        formatter:(params)=> {
          const idx = Math.max(0, Number(params[0].axisValue) - 1);
          const d = dates[idx] ?? "";
          const raceName = d ? getRaceNameByDate(d) : "";
          const head = raceName ? `G${idx + 1}　${raceName}（${d}）` : `G${idx + 1}（${d}）`;

          const lines = params.map(p=>{
            const v=Number(p.value??0);
            return `${p.marker} ${p.seriesName}: <b>${isPct?fmtPct(v):"¥"+fmtJPY(v)}</b>`;
          }).join("<br>");

          return `${head}<br>${lines}`;
        }
      },
      series
    };

    if (showZero) {
      opt.series.forEach(s => s.markLine = {
        symbol:'none',
        lineStyle:{ type:'dashed', opacity:.5 },
        data:[{ yAxis:0 }]
      });
    }

    chart.setOption(opt);
    return chart;
  }

  // ========= 収支表（ヒートマップ） =========

  // ★シート上のレース名（揺れ）→表示用省略名へ寄せる
  // 例: "フェブラリーS（2月22日）" / "フェブラリーS" / "フェブラリーステークス" / "東京優駿（日本ダービー）" etc
  const normalize = (s) => String(s ?? "")
    .replace(/（.*?）/g, "")   // かっこの日付など除去
    .replace(/\s+/g, "")
    .trim();

  const RACE_ALIAS = (() => {
    const m = new Map();

    // 基本（表示名→表示名）
    TABLE_RACES.forEach(r => m.set(normalize(r), r));

    // よくある揺れを追加（必要に応じて増やせる）
    m.set(normalize("フェブラリーステークス"), "フェブラリーS");
    m.set(normalize("スプリンターズステークス"), "スプリンターズS");
    m.set(normalize("朝日杯フューチュリティステークス"), "朝日杯フューチュリティS");
    m.set(normalize("ホープフルステークス"), "ホープフルS");
    m.set(normalize("オークス"), "優駿牝馬（オークス）");
    m.set(normalize("日本ダービー"), "東京優駿（日本ダービー）");
    m.set(normalize("東京優駿"), "東京優駿（日本ダービー）");
    m.set(normalize("優駿牝馬"), "優駿牝馬（オークス）");

    return m;
  })();

  function toDisplayRaceName(raw) {
    const key = normalize(raw);
    return RACE_ALIAS.get(key) || raw; // マッチしない場合はそのまま
  }

  // ★順番はTABLE_RACESで固定（GASのrows順は無視する）
  function sortProfitRowsByMaster(profitTable) {
    const headers = profitTable?.headers ?? [];
    const rows = (profitTable?.rows ?? []).slice();
    if (headers.length < 2) return profitTable;

    const peopleCount = headers.length - 1;

    // rowsを表示名でMap化
    const rowMap = new Map();
    for (const r of rows) {
      const rawRace = String(r?.[0] ?? "");
      const disp = toDisplayRaceName(rawRace);
      const copied = r.slice();
      copied[0] = disp;
      rowMap.set(disp, copied);
    }

    // TABLE_RACES順で埋める（欠けは0埋め）
    const sorted = TABLE_RACES.map(raceName => {
      if (rowMap.has(raceName)) return rowMap.get(raceName);
      return [raceName, ...Array(peopleCount).fill(0)];
    });

    return { headers, rows: sorted };
  }

  function buildProfitTableOption(profitTableRaw) {
    const profitTable = sortProfitRowsByMaster(profitTableRaw);
    const headers = profitTable?.headers ?? [];
    const rows = profitTable?.rows ?? [];

    if (headers.length < 2 || rows.length === 0) {
      return { option: null };
    }

    const people = headers.slice(1);
    const races = rows.map(r => String(r[0] ?? ""));

    let min = Infinity, max = -Infinity;
    const data = []; // [x, y, v]

    for (let y = 0; y < rows.length; y++) {
      const r = rows[y];
      for (let x = 0; x < people.length; x++) {
        const v = Number(r[x + 1] ?? 0);
        if (!Number.isNaN(v)) {
          min = Math.min(min, v);
          max = Math.max(max, v);
        }
        data.push([x, y, v]);
      }
    }

    const absMax = Math.max(Math.abs(min), Math.abs(max)) || 1;

    const mobile = isMobile();

    // ★iPhoneで横スクロールなしで「収める」前提のレイアウト
    // leftは詰める / 列はやや広げる / 右余白を減らす
    const leftW = mobile ? 96 : 160;
    const gridRight = mobile ? 4 : 16;

    const cellH = mobile ? 24 : 26;

    const option = {
      animation: false,
      backgroundColor: 'transparent',

      grid: {
        top: 36,
        left: leftW,
        right: gridRight,
        bottom: 10,
        containLabel: false
      },

      xAxis: {
        type: 'category',
        data: people,
        axisLabel: {
          color:'rgba(233,238,252,.98)',
          fontSize: mobile ? 13 : 12,
          fontWeight: 900,
          interval: 0,
          margin: 10
        },
        axisLine: { lineStyle: { color:'rgba(255,255,255,.18)' } },
        axisTick: { alignWithLabel: true }
      },

      yAxis: {
        type: 'category',
        data: races,
        axisLabel: {
          color:'rgba(233,238,252,.86)',
          fontSize: mobile ? 11 : 11,
          width: leftW - 8,
          overflow: 'truncate'
        },
        axisLine: { lineStyle: { color:'rgba(255,255,255,.14)' } },
        axisTick: { show: false }
      },

      visualMap: {
        type: 'continuous',
        min: -absMax,
        max: absMax,
        show: false,
        calculable: false,
        inRange: { color: ['#ff6b6b', '#141a2a', '#7aa2ff'] }
      },

      tooltip: {
        trigger: 'item',
        backgroundColor: 'rgba(10,14,26,.95)',
        borderColor: 'rgba(255,255,255,.18)',
        textStyle: { color:'#e9eefc' },
        formatter: (p) => {
          const x = p.data[0], y = p.data[1], v = p.data[2];
          const name = people[x];
          const race = races[y];
          const sign = v > 0 ? '+' : '';
          return `${race}<br>${name}: <b>${sign}${fmtJPY(v)}円</b>`;
        }
      },

      series: [{
        type: 'custom',
        data,
        renderItem: (params, api) => {
          const x = api.value(0);
          const y = api.value(1);
          const val = api.value(2);

          const point = api.coord([x, y]);
          const size = api.size([1, 1]);

          const w = size[0];
          const h = Math.max(cellH, size[1]);

          const rect = {
            x: point[0] - w/2,
            y: point[1] - h/2,
            width: w,
            height: h
          };

          const sign = val > 0 ? '+' : '';
          const text = `${sign}${fmtJPY(val)}`;

          const stroke = 'rgba(255,255,255,.10)';
          const lw = 1;
          const txt = Math.abs(val) > absMax * 0.55 ? 'rgba(255,255,255,.92)' : 'rgba(233,238,252,.90)';

          return {
            type: 'group',
            children: [
              {
                type: 'rect',
                shape: rect,
                style: {
                  fill: api.visual('color'),
                  stroke,
                  lineWidth: lw
                }
              },
              {
                type: 'text',
                style: {
                  x: rect.x + rect.width/2,
                  y: rect.y + rect.height/2,
                  text,
                  fill: txt,
                  fontSize: mobile ? 10 : 11,  // ★セル内数字を1つ小さく
                  fontWeight: 700,
                  align: 'center',
                  verticalAlign: 'middle'
                }
              }
            ]
          };
        }
      }]
    };

    return { option };
  }

  function makeProfitTable() {
    const dom = document.getElementById("profitTable");
    const chart = echarts.init(dom);

    return {
      chart,
      set: (profitTable) => {
        const { option } = buildProfitTableOption(profitTable);

        if (!option) {
          chart.clear();
          chart.setOption({
            title: { text: '収支データがありません', left: 'center', top: 'middle',
              textStyle: { color:'rgba(233,238,252,.65)', fontSize: 12 } }
          });
          return;
        }
        chart.setOption(option, true);
      }
    };
  }

  // ========= 描画制御 =========
  let dashCharts = [];
  let tableChartWrap = null;
  let resizeBound = false;

  function nextPaint() {
    return new Promise(resolve => {
      requestAnimationFrame(() => setTimeout(resolve, 0));
    });
  }

  async function renderDashboard() {
    dashCharts.forEach(c => safeDispose(c));
    dashCharts = [];

    const updated = document.getElementById("updatedDash");
    updated.textContent = "updated: loading...";

    // ★表示直後のDOM確定待ち（初回描画失敗対策）
    await nextPaint();

    const data = await getAllDataFast();
    const participants = data.summary.map(d => d.participant);

    dashCharts.push(makeBar("barBet", "掛け金合計", participants, data.summary.map(d=>Number(d.bet_total??0)), false));
    dashCharts.push(makeBar("barProfit", "収支", participants, data.summary.map(d=>Number(d.profit_total??0)), false));
    dashCharts.push(makeBar("barRoi", "回収率", participants, data.summary.map(d=>Number(d.roi??0)), true));

    dashCharts.push(makeLines("lineCumBet", data.cumBet, false, false));
    dashCharts.push(makeLines("lineCumProfit", data.cumProfit, false, true));
    dashCharts.push(makeLines("lineCumRoi", data.cumRoi, true, false));

    updated.textContent = "updated: " + new Date().toLocaleString("ja-JP");

    if (!resizeBound) bindResize();
  }

  async function renderTable() {
    const updated = document.getElementById("updatedTable");
    updated.textContent = "updated: loading...";

    // ★表示直後のDOM確定待ち（初回描画失敗対策）
    await nextPaint();

    const data = await getAllDataFast();

    if (!tableChartWrap) {
      tableChartWrap = makeProfitTable();
    }

    // ★init直後にresizeを噛ませる（iPhoneで0幅判定になるのを防ぐ）
    tableChartWrap.chart.resize();

    tableChartWrap.set(data.profitTable);

    // ★描画後もう一回resize（初回だけの保険）
    await nextPaint();
    tableChartWrap.chart.resize();

    updated.textContent = "updated: " + new Date().toLocaleString("ja-JP");

    if (!resizeBound) bindResize();
  }

  function bindResize() {
    resizeBound = true;
    window.addEventListener("resize", () => {
      dashCharts.forEach(c => c?.resize?.());
      tableChartWrap?.chart?.resize?.();
    });
  }

  // ========= セレクト =========
  function fillSelect(id, items) {
    const sel = document.getElementById(id);
    sel.innerHTML = "";
    items.forEach(v => {
      const opt = document.createElement("option");
      opt.value = v;
      opt.textContent = v;
      sel.appendChild(opt);
    });
  }

  fillSelect("name", PARTICIPANTS);
  fillSelect("race", RACES);

  ["name","race","bet","pay","keepAmount"].forEach(id => {
    document.getElementById(id).addEventListener("change", saveFormState);
    document.getElementById(id).addEventListener("input", saveFormState);
  });

  loadFormState();
  setTimeout(prefetchAllData, 0);

  const savedTab = localStorage.getItem("waku_g1_active_tab");
  if (savedTab === "dashboard" || savedTab === "table" || savedTab === "history") setTab(savedTab);

  // ★初期表示のタブがdashboard/tableの場合、必ず初回描画する
  (async () => {
    try {
      if (savedTab === "dashboard") await renderDashboard();
      if (savedTab === "table") await renderTable();
    } catch (e) {
      alert("取得エラー: " + e.message);
    }
  })();

  document.querySelectorAll(".tabbtn").forEach(btn => {
    btn.addEventListener("click", async () => {
      const t = btn.dataset.tab;
      setTab(t);

      try {
        if (t === "dashboard") await renderDashboard();
        if (t === "table") await renderTable();
      } catch (e) {
        alert("取得エラー: " + e.message);
      }
    });
  });

  document.getElementById("toDash").addEventListener("click", async () => {
    setTab("dashboard");
    try { await renderDashboard(); }
    catch (e) { alert("ダッシュボード取得エラー: " + e.message); }
  });

  document.getElementById("toInputFromDash").addEventListener("click", () => setTab("input"));
  document.getElementById("toInputFromTable").addEventListener("click", () => setTab("input"));

  document.getElementById("reloadDashBtn").addEventListener("click", async () => {
    try {
      cachedAllDataAt = 0;
      await renderDashboard();
    } catch (e) {
      alert("再読み込みエラー: " + e.message);
    }
  });

  document.getElementById("reloadTableBtn").addEventListener("click", async () => {
    try {
      cachedAllDataAt = 0;
      await renderTable();
    } catch (e) {
      alert("再読み込みエラー: " + e.message);
    }
  });

  document.getElementById("entryForm").addEventListener("submit", async (ev) => {
    ev.preventDefault();

    const name = document.getElementById("name").value;
    const race = document.getElementById("race").value;
    const bet  = Number(document.getElementById("bet").value || 0);
    const pay  = Number(document.getElementById("pay").value || 0);

    try {
      await postEntry({ name, race, bet, pay });

      const keepAmount = document.getElementById("keepAmount").checked;
      if (!keepAmount) {
        document.getElementById("bet").value = "";
        document.getElementById("pay").value = "";
      }

      saveFormState();
      prefetchAllData();

    } catch (e) {
      alert(e.message);
    }
  });
</script>
</body>
</html>
