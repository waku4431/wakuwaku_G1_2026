<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>わくわくG1サイト 2026</title>

  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>

  <style>
    :root{
      --bg:#0b1020;
      --text:#e9eefc;
      --muted:#9fb0dd;
      --border:rgba(255,255,255,.10);
      --accent:#7aa2ff;
      --danger:#ff6b6b;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", "Hiragino Kaku Gothic ProN", "Yu Gothic", sans-serif;
      background: radial-gradient(1200px 600px at 50% -100px, #1b2a5a 0%, var(--bg) 55%, #070a14 100%);
      color:var(--text);
    }
    header{
      padding:16px 14px 10px;
      max-width:1200px; margin:0 auto;
      display:flex; flex-direction:column; gap:10px;
    }
    h1{margin:0; font-size:20px; letter-spacing:.2px}

    .tabs{display:flex; gap:8px; flex-wrap:wrap;}
    .tabbtn{
      border:1px solid var(--border);
      background: rgba(255,255,255,.03);
      color: var(--text);
      padding:8px 12px;
      border-radius:12px;
      cursor:pointer;
      font-size:13px;
      white-space:nowrap;
    }
    .tabbtn.active{
      border-color: rgba(122,162,255,.6);
      background: rgba(122,162,255,.12);
    }

    .wrap{max-width:1200px; margin:0 auto; padding:10px 12px 26px;}

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border:1px solid var(--border);
      border-radius:16px;
      padding:8px;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
      overflow:hidden;
    }

    .form{
      display:grid;
      gap:10px;
      grid-template-columns: 1fr 1fr;
    }
    .form .full{grid-column:1 / -1;}
    label{display:block; font-size:12px; color:var(--muted); margin-bottom:6px;}
    input, select{
      width:100%;
      padding:12px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.20);
      color:var(--text);
      outline:none;
      font-size:16px;
    }
    input::placeholder{color:rgba(233,238,252,.45);}
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .btn{
      border:1px solid var(--border);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      font-size:13px;
    }
    .btn.primary{
      border-color: rgba(122,162,255,.6);
      background: rgba(122,162,255,.18);
    }
    .badge{
      border:1px solid var(--border);
      padding:6px 10px;
      border-radius:999px;
      background:rgba(255,255,255,.03);
      color: var(--muted);
      font-size:12px;
    }
    .hidden{display:none !important;}
    .hint{font-size:12px; color:rgba(233,238,252,.65);}

    .grid{
      display:grid; gap:12px;
      grid-template-columns: repeat(12, 1fr);
    }
    .c1{grid-column: span 4;}
    .c2{grid-column: span 4;}
    .c3{grid-column: span 4;}
    .c4{grid-column: span 4;}
    .c5{grid-column: span 4;}
    .c6{grid-column: span 4;}

    .chart{width:100%; height:320px;}
    .chartTall{width:100%; height:360px;}

    /* 収支表タブ */
    .tableWrap{
      overflow-x:auto;
      -webkit-overflow-scrolling:touch;
      border-radius:12px;
    }
    .chartTable{height:560px;}

    @media (max-width: 900px){
      .form{grid-template-columns: 1fr;}
      .c1,.c2,.c3,.c4,.c5,.c6{grid-column: span 12;}
      .chart{height:295px;}
      .chartTall{height:335px;}
      .chartTable{height:520px;}
    }

    a.linkcard{
      display:block;
      flex:1;
      min-width: 240px;
      text-decoration:none;
      color: var(--text);
      border:1px solid var(--border);
      background: rgba(255,255,255,.03);
      border-radius:16px;
      padding:14px;
    }
    a.linkcard:hover{
      background: rgba(255,255,255,.06);
      border-color: rgba(255,255,255,.18);
    }
    .linktitle{font-weight:800; margin-bottom:6px;}
    .linkurl{
      font-size:12px;
      color: rgba(233,238,252,.65);
      word-break: break-all;
    }

    /* ★縮小中だけ中央寄せ（左の空白を消す） */
    .tableWrap.centering{
      display:flex;
      justify-content:center;
    }

    /* ★iPhoneは横スクロールさせず、縮小で収める */
    @media (max-width: 900px){
      .tableWrap{ overflow-x:hidden; }
    }
  </style>
</head>

<body>
<header>
  <div><h1>わくわくG1サイト 2026</h1></div>
  <div class="tabs">
    <button class="tabbtn active" data-tab="input">入力</button>
    <button class="tabbtn" data-tab="dashboard">ダッシュボード</button>
    <button class="tabbtn" data-tab="table">収支表</button>
    <button class="tabbtn" data-tab="history">History</button>
  </div>
</header>

<div class="wrap">
  <!-- INPUT -->
  <section id="tab-input" class="card">
    <div class="row" style="justify-content:space-between; margin-bottom:8px;">
      <div class="hint">
        送信後も <b>参加者/レース</b> を保持。金額も保持したい場合は右の設定をON。
      </div>
      <label class="row" style="margin:0; gap:8px;">
        <input id="keepAmount" type="checkbox" style="width:auto; transform:scale(1.1);" />
        <span class="hint">金額も保持</span>
      </label>
    </div>

    <form id="entryForm" class="form">
      <div>
        <label>参加者</label>
        <select id="name" required></select>
      </div>

      <div>
        <label>G1レース名</label>
        <select id="race" required></select>
      </div>

      <div>
        <label>掛け金（円）</label>
        <input id="bet" type="number" inputmode="numeric" min="0" step="100" placeholder="例: 1000" required />
      </div>

      <div>
        <label>回収額（円）</label>
        <input id="pay" type="number" inputmode="numeric" min="0" step="100" placeholder="例: 0" required />
      </div>

      <div class="full row" style="justify-content:space-between;">
        <button class="btn primary" type="submit">送信</button>
        <div class="row">
          <button class="btn" type="button" id="toDash">ダッシュボードへ</button>
        </div>
      </div>
    </form>
  </section>

  <!-- DASHBOARD -->
  <section id="tab-dashboard" class="hidden">
    <div class="row" style="justify-content:space-between; margin: 0 0 10px 0;">
      <span class="badge" id="updatedDash">updated: -</span>
      <div class="row">
        <button class="btn" id="reloadDashBtn" type="button">再読み込み</button>
        <button class="btn" id="toInputFromDash" type="button">入力へ</button>
      </div>
    </div>

    <div class="grid">
      <div class="card c1"><h2 style="margin:0 0 6px; color:var(--muted); font-size:13px;">掛け金合計 [円]</h2><div id="barBet" class="chart"></div></div>
      <div class="card c2"><h2 style="margin:0 0 6px; color:var(--muted); font-size:13px;">収支 [円]</h2><div id="barProfit" class="chart"></div></div>
      <div class="card c3"><h2 style="margin:0 0 6px; color:var(--muted); font-size:13px;">回収率 [%]</h2><div id="barRoi" class="chart"></div></div>

      <div class="card c4"><h2 style="margin:0 0 6px; color:var(--muted); font-size:13px;">累積掛け金 [円]</h2><div id="lineCumBet" class="chartTall"></div></div>
      <div class="card c5"><h2 style="margin:0 0 6px; color:var(--muted); font-size:13px;">累積収支 [円] <span class="hint">0ライン</span></h2><div id="lineCumProfit" class="chartTall"></div></div>
      <div class="card c6"><h2 style="margin:0 0 6px; color:var(--muted); font-size:13px;">累積回収率 [%]</h2><div id="lineCumRoi" class="chartTall"></div></div>
    </div>
  </section>

  <!-- TABLE -->
  <section id="tab-table" class="hidden">
    <div class="row" style="justify-content:space-between; margin: 0 0 10px 0;">
      <span class="badge" id="updatedTable">updated: -</span>
      <div class="row">
        <button class="btn" id="reloadTableBtn" type="button">再読み込み</button>
        <button class="btn" id="toInputFromTable" type="button">入力へ</button>
      </div>
    </div>

    <div class="card">
      <h2 style="margin:0 0 6px; color:var(--muted); font-size:13px;">収支表（ヒートマップ）</h2>
      <div id="profitTableWrap" class="tableWrap">
        <div id="profitTable" class="chartTable"></div>
      </div>
    </div>
  </section>

  <!-- HISTORY -->
  <section id="tab-history" class="hidden">
    <div class="card">
      <h2 style="margin:0 0 10px; color:var(--muted); font-size:13px;">過去の結果</h2>

      <div class="row" style="gap:12px;">
        <a class="linkcard" href="https://waku4431.github.io/wakuwaku_G1/" target="_blank" rel="noopener">
          <div class="linktitle">2025（去年のサイト）</div>
          <div class="linkurl">https://waku4431.github.io/wakuwaku_G1/</div>
        </a>

        <a class="linkcard" href="https://docs.google.com/spreadsheets/d/1V1nxbAoVL6SjKAgII8QPmEYw8A5YI-tZUzYFDhKDx1Y/edit?gid=614154890#gid=614154890" target="_blank" rel="noopener">
          <div class="linktitle">2024（スプレッドシート）</div>
          <div class="linkurl">https://docs.google.com/spreadsheets/d/1V1nxbAoVL6SjKAgII8QPmEYw8A5YI-tZUzYFDhKDx1Y/</div>
        </a>
      </div>

      <div class="hint" style="margin-top:10px;">※リンクは新しいタブで開きます</div>
    </div>
  </section>
</div>

<script>
  // ========= 本番WebアプリURL =========
  const GAS_BASE = "https://script.google.com/macros/s/AKfycbw1jiY51U3elE5tyArrcmDH0nYKtJ3N4zrnHx6TNmzojIVOl4-njJaIC7WUlcgp32sbXA/exec";

  // ========= マスタ =========
  const PARTICIPANTS = ["わくだ","きよもと","せきざわ","たきざわ","粗品"];

  // ★入力のセレクト用（あなたの統一リスト：日付なし）
  const RACES = [
    "フェブラリーS",
    "高松宮記念",
    "大阪杯",
    "桜花賞",
    "皐月賞",
    "天皇賞（春）",
    "NHKマイルカップ",
    "ヴィクトリアマイル",
    "優駿牝馬（オークス）",
    "東京優駿（日本ダービー）",
    "安田記念",
    "宝塚記念",
    "スプリンターズS",
    "秋華賞",
    "菊花賞",
    "天皇賞（秋）",
    "エリザベス女王杯",
    "マイルチャンピオンシップ",
    "ジャパンカップ",
    "チャンピオンズカップ",
    "阪神ジュベナイルフィリーズ",
    "朝日杯フューチュリティS",
    "ホープフルS",
    "有馬記念"
  ];

  // ========= モバイル判定 =========
  const isMobile = () => window.innerWidth <= 420;

  // ========= 色固定 =========
  const COLOR_MAP = {
    "わくだ":   "#7aa2ff",
    "きよもと": "#ffd166",
    "せきざわ": "#ff6b6b",
    "たきざわ": "#6ee7b7",
    "粗品":     "#a78bfa",
  };
  const getColor = (name) => COLOR_MAP[name] || "#7aa2ff";

  // ========= データ側のレース名ゆれ吸収 → 表示名へ =========
  // （GAS/シート側が "フェブラリーステークス（2月22日）" みたいでも、ここで "フェブラリーS" に寄せる）
  const RACE_ALIAS = new Map([
    ["フェブラリーステークス", "フェブラリーS"],
    ["フェブラリーS", "フェブラリーS"],

    ["高松宮記念", "高松宮記念"],
    ["大阪杯", "大阪杯"],
    ["桜花賞", "桜花賞"],
    ["皐月賞", "皐月賞"],
    ["天皇賞（春）", "天皇賞（春）"],
    ["天皇賞(春)", "天皇賞（春）"],

    ["NHKマイルカップ", "NHKマイルカップ"],
    ["ヴィクトリアマイル", "ヴィクトリアマイル"],

    ["優駿牝馬", "優駿牝馬（オークス）"],
    ["オークス", "優駿牝馬（オークス）"],
    ["優駿牝馬（オークス）", "優駿牝馬（オークス）"],

    ["東京優駿", "東京優駿（日本ダービー）"],
    ["日本ダービー", "東京優駿（日本ダービー）"],
    ["東京優駿（日本ダービー）", "東京優駿（日本ダービー）"],

    ["安田記念", "安田記念"],
    ["宝塚記念", "宝塚記念"],

    ["スプリンターズステークス", "スプリンターズS"],
    ["スプリンターズS", "スプリンターズS"],

    ["秋華賞", "秋華賞"],
    ["菊花賞", "菊花賞"],

    ["天皇賞（秋）", "天皇賞（秋）"],
    ["天皇賞(秋)", "天皇賞（秋）"],

    ["エリザベス女王杯", "エリザベス女王杯"],

    ["マイルチャンピオンシップ", "マイルチャンピオンシップ"],
    ["マイルCS", "マイルチャンピオンシップ"],

    ["ジャパンカップ", "ジャパンカップ"],

    ["チャンピオンズカップ", "チャンピオンズカップ"],
    ["チャンピオンズC", "チャンピオンズカップ"],

    ["阪神ジュベナイルフィリーズ", "阪神ジュベナイルフィリーズ"],
    ["阪神JF", "阪神ジュベナイルフィリーズ"],

    ["朝日杯フューチュリティステークス", "朝日杯フューチュリティS"],
    ["朝日杯フューチュリティS", "朝日杯フューチュリティS"],
    ["朝日杯FS", "朝日杯フューチュリティS"],

    ["ホープフルステークス", "ホープフルS"],
    ["ホープフルS", "ホープフルS"],

    ["有馬記念", "有馬記念"],
  ]);

  function normalizeRaceKey(s) {
    if (!s) return "";
    let t = String(s).trim();
    t = t.replace(/（.*?）/g, ""); // ★日付など括弧を落とす（"（2月22日）" を消す）
    t = t.replace(/\s+/g, "");
    return t;
  }
  function toDisplayRaceName(raw) {
    const key = normalizeRaceKey(raw);
    return RACE_ALIAS.get(key) || raw;
  }

  // ========= 先読みキャッシュ =========
  let cachedAllData = null;
  let cachedAllDataAt = 0;
  let prefetchPromise = null;
  const CACHE_MS = 30 * 1000;

  async function loadData() {
    const url = `${GAS_BASE}?type=all&t=${Date.now()}`;
    const res = await fetch(url, { method:"GET" });
    const json = await res.json();
    if (!json.ok) throw new Error(json.error || "GAS ok=false");
    return json;
  }

  async function getAllDataFast() {
    const now = Date.now();
    if (cachedAllData && (now - cachedAllDataAt) < CACHE_MS) return cachedAllData;

    if (prefetchPromise) {
      const data = await prefetchPromise;
      cachedAllData = data;
      cachedAllDataAt = Date.now();
      prefetchPromise = null;
      return data;
    }

    prefetchPromise = loadData();
    const data = await prefetchPromise;
    cachedAllData = data;
    cachedAllDataAt = Date.now();
    prefetchPromise = null;
    return data;
  }

  function prefetchAllData() {
    if (!prefetchPromise && (!cachedAllData || (Date.now() - cachedAllDataAt) > CACHE_MS)) {
      prefetchPromise = loadData()
        .then(d => {
          cachedAllData = d;
          cachedAllDataAt = Date.now();
          return d;
        })
        .finally(() => { prefetchPromise = null; });
    }
  }

  // ========= 入力保持 =========
  const LS_KEY = "waku_g1_form_state_v1";

  function saveFormState() {
    const keepAmount = document.getElementById("keepAmount").checked;
    const state = {
      keepAmount,
      name: document.getElementById("name").value,
      race: document.getElementById("race").value,
      bet: keepAmount ? document.getElementById("bet").value : "",
      pay: keepAmount ? document.getElementById("pay").value : "",
    };
    localStorage.setItem(LS_KEY, JSON.stringify(state));
  }

  function loadFormState() {
    const raw = localStorage.getItem(LS_KEY);
    if (!raw) return;
    try {
      const s = JSON.parse(raw);
      document.getElementById("keepAmount").checked = !!s.keepAmount;
      if (s.name) document.getElementById("name").value = s.name;
      if (s.race) document.getElementById("race").value = s.race;
      if (s.keepAmount) {
        if (s.bet !== undefined) document.getElementById("bet").value = s.bet;
        if (s.pay !== undefined) document.getElementById("pay").value = s.pay;
      }
    } catch {}
  }

  // ========= タブ切り替え =========
  function setTab(tabName) {
    document.querySelectorAll(".tabbtn").forEach(b => {
      b.classList.toggle("active", b.dataset.tab === tabName);
    });
    document.getElementById("tab-input").classList.toggle("hidden", tabName !== "input");
    document.getElementById("tab-dashboard").classList.toggle("hidden", tabName !== "dashboard");
    document.getElementById("tab-table").classList.toggle("hidden", tabName !== "table");
    document.getElementById("tab-history").classList.toggle("hidden", tabName !== "history");
    localStorage.setItem("waku_g1_active_tab", tabName);
    if (tabName !== "dashboard" && tabName !== "table") prefetchAllData();
  }

  // ========= POST =========
  async function postEntry({name, race, bet, pay}) {
    const body = new URLSearchParams({ name, race, bet: String(bet), pay: String(pay) });
    const res = await fetch(GAS_BASE, {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8" },
      body
    });
    const text = (await res.text()).trim();
    if (!res.ok || !text.startsWith("OK")) throw new Error("POST失敗: " + text);
    return text;
  }

  // ========= ECharts =========
  const fmtJPY = (v) => new Intl.NumberFormat('ja-JP').format(v ?? 0);
  const fmtPct = (v) => `${Number(v ?? 0).toFixed(2)}%`;

  function safeDispose(chart) {
    try { chart?.dispose?.(); } catch {}
  }

  // ★余白最適化
  function getChartLayout() {
    const mobile = isMobile();
    return {
      mobile,
      gridLeft:  mobile ? 5 : 46,
      gridRight: mobile ? 10 : 14,
      gridTopBar: 18,
      gridTopLine: 30,
      gridBottomBar:  mobile ? 32 : 40,
      gridBottomLine: mobile ? 15 : 34,
      fontAxis: mobile ? 9 : 11,
      fontLegend: mobile ? 10 : 12,
      axisMargin: mobile ? 6 : 8,
      rotateBarX: 35
    };
  }

  function makeBar(el, title, participants, values, isPct=false) {
    const chart = echarts.init(document.getElementById(el));
    const L = getChartLayout();

    chart.setOption({
      backgroundColor:'transparent',
      grid:{ left:L.gridLeft, right:L.gridRight, top:L.gridTopBar, bottom:L.gridBottomBar, containLabel:true },
      xAxis:{
        type:'category',
        data:participants,
        axisLabel:{ color:'rgba(233,238,252,.85)', rotate:L.rotateBarX, fontSize:L.fontAxis, margin:L.axisMargin }
      },
      yAxis:{
        type:'value',
        axisLabel:{
          color:'rgba(233,238,252,.65)',
          formatter:(v)=> isPct?`${v}%`:fmtJPY(v),
          fontSize:L.fontAxis,
          margin:L.axisMargin
        },
        splitLine:{ lineStyle:{ color:'rgba(255,255,255,.08)' } }
      },
      tooltip:{
        trigger:'axis',
        axisPointer:{ type:'shadow' },
        formatter:(ps)=> {
          const p=ps[0], v=Number(p.value??0);
          return `${p.name}<br>${title}: <b>${isPct?fmtPct(v):"¥"+fmtJPY(v)}</b>`;
        }
      },
      series:[{
        type:'bar',
        data:values,
        barMaxWidth:42,
        itemStyle:{
          color:(params)=>getColor(params.name),
          borderRadius:[10,10,0,0]
        },
        label:{
          show:true,
          position:'insideTop',
          color:'rgba(233,238,252,.95)',
          fontSize: L.mobile ? 11 : 12,
          formatter:(p)=> {
            const v=Number(p.value??0);
            return isPct?`${v.toFixed(0)}%`:`¥${fmtJPY(v)}`;
          }
        }
      }]
    });
    return chart;
  }

  function makeLines(el, block, isPct=false, showZero=false) {
    const chart = echarts.init(document.getElementById(el));
    const L = getChartLayout();

    const dates = block?.dates ?? [];
    const xLabels = dates.map((_, i) => String(i + 1)); // 1..N

    const legends = block?.series ? Object.keys(block.series) : [];
    const series = legends.map(name => ({
      name,
      type:'line',
      data:block.series[name],
      smooth:false,
      showSymbol:false,
      lineStyle:{ width:2, color:getColor(name) },
      emphasis:{ focus:'series' }
    }));

    const opt = {
      backgroundColor:'transparent',
      legend:{
        data:legends,
        top:0,
        left:0,
        itemWidth:14,
        itemHeight:8,
        textStyle:{ color:'rgba(233,238,252,.75)', fontSize:L.fontLegend }
      },
      grid:{ left:L.gridLeft, right:L.gridRight, top:L.gridTopLine, bottom:L.gridBottomLine, containLabel:true },
      xAxis:{
        type:'category',
        data:xLabels,
        boundaryGap:false,
        axisTick:{ alignWithLabel:true },
        axisLabel:{
          color:'rgba(233,238,252,.75)',
          fontSize:L.fontAxis,
          margin:6,
          interval: 0,
          formatter: (val) => {
            const n = Number(val);
            const last = xLabels.length;
            if (n === 1 || n === last) return String(n);
            return (n % 2 === 0) ? String(n) : "";
          }
        },
        name: "レース回数",
        nameLocation: "middle",
        nameGap: L.mobile ? 20 : 24,
        nameTextStyle:{
          color:'rgba(233,238,252,.65)',
          fontSize: L.mobile ? 10 : 12
        }
      },
      yAxis:{
        type:'value',
        axisLabel:{
          color:'rgba(233,238,252,.65)',
          formatter:(v)=> isPct?`${v}%`:fmtJPY(v),
          fontSize:L.fontAxis,
          margin:L.axisMargin
        },
        splitLine:{ lineStyle:{ color:'rgba(255,255,255,.08)' } }
      },
      tooltip:{
        trigger:'axis',
        formatter:(params)=> {
          const idx = Math.max(0, Number(params[0].axisValue) - 1);
          const d = dates[idx] ?? "";
          const head = `G${idx + 1}`;
          const lines = params.map(p=>{
            const v=Number(p.value??0);
            return `${p.marker} ${p.seriesName}: <b>${isPct?fmtPct(v):"¥"+fmtJPY(v)}</b>`;
          }).join("<br>");
          return `${head}<br>${lines}`;
        }
      },
      series
    };

    if (showZero) {
      opt.series.forEach(s => s.markLine = {
        symbol:'none',
        lineStyle:{ type:'dashed', opacity:.5 },
        data:[{ yAxis:0 }]
      });
    }

    chart.setOption(opt);
    return chart;
  }

  // ========= 収支表（ヒートマップ） =========

  // ★時系列順（固定）：フェブラリーSが最初、有馬記念が最後
  const RACE_ORDER_LIST = [...RACES]; // すでに時系列で並んでる前提
  const RACE_ORDER = (() => {
    const m = new Map();
    RACE_ORDER_LIST.forEach((name, i) => m.set(name, i));
    return m;
  })();

  function sortProfitRowsByMaster(profitTable) {
    const headers = profitTable?.headers ?? [];
    const rows = (profitTable?.rows ?? []).slice();
    if (rows.length === 0) return profitTable;

    // rows: [race, v1, v2...]
    const mappedRows = rows.map(r => {
      const rawRace = String(r?.[0] ?? "");
      const disp = toDisplayRaceName(rawRace);
      const copied = r.slice();
      copied[0] = disp;
      return copied;
    });

    const sorted = mappedRows.sort((a, b) => {
      const ai = RACE_ORDER.has(a[0]) ? RACE_ORDER.get(a[0]) : 9999;
      const bi = RACE_ORDER.has(b[0]) ? RACE_ORDER.get(b[0]) : 9999;
      if (ai !== bi) return ai - bi;
      return String(a[0]).localeCompare(String(b[0]), "ja");
    });

    return { headers, rows: sorted };
  }

  function buildProfitTableOption(profitTableRaw) {
    const profitTable = sortProfitRowsByMaster(profitTableRaw);
    const headers = profitTable?.headers ?? [];
    const rows = profitTable?.rows ?? [];

    if (headers.length < 2 || rows.length === 0) {
      return { option: null, designWidth: 600 };
    }

    // ヘッダの並び：レース名 + 人
    const people = headers.slice(1);
    const races = rows.map(r => String(r[0] ?? ""));

    let min = Infinity, max = -Infinity;
    const data = []; // [x, y, v]

    for (let y = 0; y < rows.length; y++) {
      const r = rows[y];
      for (let x = 0; x < people.length; x++) {
        const v = Number(r[x + 1] ?? 0);
        if (!Number.isNaN(v)) {
          min = Math.min(min, v);
          max = Math.max(max, v);
        }
        data.push([x, y, v]);
      }
    }

    const absMax = Math.max(Math.abs(min), Math.abs(max)) || 1;

    const mobile = isMobile();

    // ★スマホは「見切れない範囲で左幅を詰める」+ 「列も詰める」
    const leftW = mobile ? 124 : 160;
    const colW  = mobile ? 82  : 112;

    const chartWidth = leftW + people.length * colW + 20;
    const cellH = mobile ? 24 : 26;

    const option = {
      animation: false,
      backgroundColor: 'transparent',

      grid: {
        top: 34,
        left: leftW,
        right: 12,
        bottom: 10,
        containLabel: false
      },

      xAxis: {
        type: 'category',
        data: people,
        axisLabel: {
          color:'rgba(233,238,252,.95)',
          fontSize: mobile ? 12 : 12,
          fontWeight: 800,        // ★名前を目立たせる
          interval: 0
        },
        axisLine: { lineStyle: { color:'rgba(255,255,255,.18)' } },
        axisTick: { alignWithLabel: true }
      },

      yAxis: {
        type: 'category',
        data: races,
        axisLabel: {
          color:'rgba(233,238,252,.85)',
          fontSize: mobile ? 11 : 11,
          width: leftW - 10,
          overflow: 'truncate',   // ★長いのは…にする（iPhoneで見切れ対策）
          formatter: (v) => v
        },
        axisLine: { lineStyle: { color:'rgba(255,255,255,.14)' } },
        axisTick: { show: false }
      },

      visualMap: {
        type: 'continuous',
        min: -absMax,
        max: absMax,
        show: false,
        calculable: false,
        inRange: {
          color: ['#ff6b6b', '#141a2a', '#7aa2ff'] // 赤→暗め→青
        }
      },

      tooltip: {
        trigger: 'item',
        backgroundColor: 'rgba(10,14,26,.95)',
        borderColor: 'rgba(255,255,255,.18)',
        textStyle: { color:'#e9eefc' },
        formatter: (p) => {
          const x = p.data[0], y = p.data[1], v = p.data[2];
          const name = people[x];
          const race = races[y];
          const sign = v > 0 ? '+' : '';
          return `${race}<br>${name}: <b>${sign}${fmtJPY(v)}円</b>`;
        }
      },

      series: [{
        type: 'custom',
        data,
        renderItem: (params, api) => {
          const x = api.value(0);
          const y = api.value(1);
          const val = api.value(2);

          const point = api.coord([x, y]);
          const size = api.size([1, 1]);

          const w = size[0];
          const h = Math.max(cellH, size[1]);

          const rect = {
            x: point[0] - w/2,
            y: point[1] - h/2,
            width: w,
            height: h
          };

          const sign = val > 0 ? '+' : '';
          const text = `${sign}${fmtJPY(val)}`;

          const stroke = 'rgba(255,255,255,.10)';
          const lw = 1;

          const txt = Math.abs(val) > absMax * 0.55 ? 'rgba(255,255,255,.92)' : 'rgba(233,238,252,.90)';

          return {
            type: 'group',
            children: [
              {
                type: 'rect',
                shape: rect,
                style: {
                  fill: api.visual('color'),
                  stroke,
                  lineWidth: lw
                }
              },
              {
                type: 'text',
                style: {
                  x: rect.x + rect.width/2,
                  y: rect.y + rect.height/2,
                  text,
                  fill: txt,
                  fontSize: mobile ? 11 : 11,
                  fontWeight: 700,
                  align: 'center',
                  verticalAlign: 'middle'
                }
              }
            ]
          };
        }
      }]
    };

    return { option, designWidth: chartWidth };
  }

  function applyMobileScaleForTable(designWidth) {
    const dom = document.getElementById("profitTable");
    const wrap = document.getElementById("profitTableWrap");
    const avail = wrap?.clientWidth || window.innerWidth;

    const safeAvail = Math.max(280, avail - 2);

    if (isMobile() && designWidth > safeAvail) {
      const s = Math.max(0.86, Math.min(1, safeAvail / designWidth));
      dom.style.width = `${designWidth}px`;
      dom.style.transform = `scale(${s})`;
      wrap.classList.add("centering");
    } else {
      dom.style.transform = "scale(1)";
      dom.style.width = "100%";
      wrap.classList.remove("centering");
    }
  }

  function makeProfitTable() {
    const dom = document.getElementById("profitTable");
    const chart = echarts.init(dom);

    return {
      chart,
      set: (profitTable) => {
        const { option, designWidth } = buildProfitTableOption(profitTable);

        applyMobileScaleForTable(designWidth);

        if (!option) {
          chart.clear();
          chart.setOption({
            title: {
              text: '収支データがありません',
              left: 'center',
              top: 'middle',
              textStyle: { color:'rgba(233,238,252,.65)', fontSize: 12 }
            }
          }, true);
          requestAnimationFrame(() => chart.resize());
          return;
        }

        chart.setOption(option, true);
        requestAnimationFrame(() => chart.resize());
      }
    };
  }

  // ========= 描画制御 =========
  let dashCharts = [];
  let tableChartWrap = null;
  let resizeBound = false;

  async function renderDashboard() {
    dashCharts.forEach(c => safeDispose(c));
    dashCharts = [];

    const updated = document.getElementById("updatedDash");
    updated.textContent = "updated: loading...";

    const data = await getAllDataFast();
    const participants = data.summary.map(d => d.participant);

    dashCharts.push(makeBar("barBet", "掛け金合計", participants, data.summary.map(d=>Number(d.bet_total??0)), false));
    dashCharts.push(makeBar("barProfit", "収支", participants, data.summary.map(d=>Number(d.profit_total??0)), false));
    dashCharts.push(makeBar("barRoi", "回収率", participants, data.summary.map(d=>Number(d.roi??0)), true));

    dashCharts.push(makeLines("lineCumBet", data.cumBet, false, false));
    dashCharts.push(makeLines("lineCumProfit", data.cumProfit, false, true));
    dashCharts.push(makeLines("lineCumRoi", data.cumRoi, true, false));

    updated.textContent = "updated: " + new Date().toLocaleString("ja-JP");

    if (!resizeBound) bindResize();
  }

  async function renderTable() {
    const updated = document.getElementById("updatedTable");
    updated.textContent = "updated: loading...";

    const data = await getAllDataFast();

    if (!tableChartWrap) tableChartWrap = makeProfitTable();
    tableChartWrap.set(data.profitTable);

    updated.textContent = "updated: " + new Date().toLocaleString("ja-JP");

    if (!resizeBound) bindResize();
  }

  function bindResize() {
    resizeBound = true;
    window.addEventListener("resize", () => {
      dashCharts.forEach(c => c?.resize?.());
      if (tableChartWrap?.chart) {
        requestAnimationFrame(() => {
          try { tableChartWrap.chart.resize(); } catch {}
        });
      }
    });
  }

  // ========= セレクト =========
  function fillSelect(id, items) {
    const sel = document.getElementById(id);
    sel.innerHTML = "";
    items.forEach(v => {
      const opt = document.createElement("option");
      opt.value = v;
      opt.textContent = v;
      sel.appendChild(opt);
    });
  }

  fillSelect("name", PARTICIPANTS);
  fillSelect("race", RACES);

  ["name","race","bet","pay","keepAmount"].forEach(id => {
    document.getElementById(id).addEventListener("change", saveFormState);
    document.getElementById(id).addEventListener("input", saveFormState);
  });

  loadFormState();

  // ★起動直後に先読み（体感を速く）
  prefetchAllData();

  // ===== 初期タブ復元 =====
  const savedTab = localStorage.getItem("waku_g1_active_tab");
  if (savedTab === "dashboard" || savedTab === "table" || savedTab === "history") {
    setTab(savedTab);
  }

  // ★display:none → block 直後はサイズが0になりがちなので、2フレーム待って描画する
  function afterVisibleRender(fn) {
    requestAnimationFrame(() => requestAnimationFrame(fn));
  }

  // 初期表示でダッシュボード/収支表なら自動描画
  afterVisibleRender(async () => {
    try {
      const t = localStorage.getItem("waku_g1_active_tab");
      if (t === "dashboard") await renderDashboard();
      if (t === "table") await renderTable();
    } catch (e) {
      alert("初期描画エラー: " + e.message);
    }
  });

  // タブ切り替え
  document.querySelectorAll(".tabbtn").forEach(btn => {
    btn.addEventListener("click", () => {
      const t = btn.dataset.tab;
      setTab(t);
      afterVisibleRender(async () => {
        try {
          if (t === "dashboard") await renderDashboard();
          if (t === "table") await renderTable();
        } catch (e) {
          alert("取得エラー: " + e.message);
        }
      });
    });
  });

  // 入力からダッシュボードへ
  document.getElementById("toDash").addEventListener("click", () => {
    setTab("dashboard");
    afterVisibleRender(async () => {
      try { await renderDashboard(); }
      catch (e) { alert("ダッシュボード取得エラー: " + e.message); }
    });
  });

  document.getElementById("toInputFromDash").addEventListener("click", () => setTab("input"));
  document.getElementById("toInputFromTable").addEventListener("click", () => setTab("input"));

  document.getElementById("reloadDashBtn").addEventListener("click", async () => {
    try {
      cachedAllDataAt = 0;
      await renderDashboard();
    } catch (e) {
      alert("再読み込みエラー: " + e.message);
    }
  });

  document.getElementById("reloadTableBtn").addEventListener("click", async () => {
    try {
      cachedAllDataAt = 0;
      await renderTable();
    } catch (e) {
      alert("再読み込みエラー: " + e.message);
    }
  });

  // 送信
  document.getElementById("entryForm").addEventListener("submit", async (ev) => {
    ev.preventDefault();

    const name = document.getElementById("name").value;
    const race = document.getElementById("race").value;
    const bet  = Number(document.getElementById("bet").value || 0);
    const pay  = Number(document.getElementById("pay").value || 0);

    try {
      await postEntry({ name, race, bet, pay });

      const keepAmount = document.getElementById("keepAmount").checked;
      if (!keepAmount) {
        document.getElementById("bet").value = "";
        document.getElementById("pay").value = "";
      }

      saveFormState();
      prefetchAllData();

    } catch (e) {
      alert(e.message);
    }
  });
</script>
</body>
</html>
